<!DOCTYPE html>
<html lang="en">
<head>
<link rel="icon" href="data:,">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Vallejo Paint Wheel</title>
<script src="data.js"></script>
<style>
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:system-ui,-apple-system,sans-serif;padding:1rem;max-width:1400px;margin:0 auto;background:#f5f5f5}
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem;flex-wrap:wrap;gap:1rem}
h1{font-size:1.8rem}
.stats{display:flex;gap:.5rem}
.stat{background:#e3f2fd;padding:.5rem 1rem;border-radius:9999px;font-size:.85rem}
.stat b{color:#1976d2}
.controls{background:white;padding:1rem;border-radius:.5rem;margin-bottom:1rem;box-shadow:0 1px 3px rgba(0,0,0,.1)}
.control-row{display:flex;gap:1rem;align-items:center;margin-bottom:1rem;flex-wrap:wrap}
.control-row:last-child{margin-bottom:0}
label{font-weight:500;font-size:.9rem;min-width:100px}
select,input[type=range]{padding:.5rem;border:1px solid #ddd;border-radius:.25rem;font:inherit;background:white;cursor:pointer}
button{padding:.5rem 1rem;border:none;background:#1976d2;color:white;border-radius:.25rem;cursor:pointer;font:inherit}
button:hover{background:#1565c0}
.btn-secondary{background:#666}
.btn-secondary:hover{background:#555}
.btn-danger{background:#d32f2f}
.btn-danger:hover{background:#c62828}
.wheel-container{background:white;padding:1.5rem;border-radius:.5rem;margin-bottom:1rem;box-shadow:0 1px 3px rgba(0,0,0,.1);display:flex;justify-content:center;position:relative}
canvas{max-width:100%;height:auto}
.paint-info{background:white;padding:1rem;border-radius:.5rem;box-shadow:0 1px 3px rgba(0,0,0,.1);margin-bottom:1rem}
.paint-info h2{font-size:1.2rem;margin-bottom:.75rem}
.paint-display{display:flex;gap:1rem;align-items:center;flex-wrap:wrap}
.paint-swatch{width:100px;height:60px;border:1px solid #ddd;border-radius:.25rem}
.paint-details{flex:1;min-width:200px}
.paint-details div{margin-bottom:.25rem}
.paint-details .id{font-weight:600;font-size:.9rem}
.paint-details .name{font-size:.9rem}
.paint-details .hex{font-size:.8rem;color:#666}
.ownership{font-size:.8rem;margin-top:.25rem;padding:.25rem .5rem;border-radius:.25rem;display:inline-block}
.ownership.owned{background:#e8f5e8;color:#2e7d32;border:1px solid #c8e6c9}
.ownership.wishlist{background:#fff3e0;color:#ef6c00;border:1px solid#ffcc80}
.ownership.missing{background:#f5f5f5;color:#666;border:1px solid #e0e0e0}
.ownership-controls{display:flex;gap:.5rem;margin-top:.5rem}
.ownership-controls button{font-size:.8rem;padding:.25rem .75rem}
.schemes{background:white;padding:1rem;border-radius:.5rem;box-shadow:0 1px 3px rgba(0,0,0,.1)}
.schemes h2{font-size:1.2rem;margin-bottom:.75rem}
.scheme{margin-bottom:1.5rem}
.scheme:last-child{margin-bottom:0}
.scheme h3{font-size:1rem;margin-bottom:.5rem;color:#666}
.scheme-colors{display:flex;gap:.5rem;flex-wrap:wrap}
.scheme-color{flex:1;min-width:120px;border:1px solid #ddd;border-radius:.25rem;padding:.5rem;background:white;cursor:pointer}
.scheme-color:hover{transform:scale(1.02)}
.scheme-color .swatch{aspect-ratio:3/1;border:1px solid #d1d5db;border-radius:.25rem;margin-bottom:.25rem}
.scheme-color .id{font-weight:600;font-size:.75rem;margin-bottom:.1rem}
.scheme-color .name{font-size:.75rem;margin-bottom:.1rem}
.tooltip{position:absolute;background:rgba(0,0,0,.8);color:white;padding:.5rem;border-radius:.25rem;font-size:.8rem;pointer-events:none;z-index:1000;max-width:200px}
.filter-options{display:flex;gap:1rem;flex-wrap:wrap}
.filter-option{display:flex;align-items:center;gap:.5rem}
.filter-option input[type=checkbox]{width:18px;height:18px}
.status{background:#e3f2fd;border:1px solid #90caf9;padding:.75rem;border-radius:.25rem;margin-bottom:1rem;font-size:.9rem;display:none}
.modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,.5);align-items:center;justify-content:center;padding:1rem;z-index:1000}
.modal.show{display:flex}
.modal-content{background:white;border-radius:.5rem;padding:1.5rem;max-width:500px;width:100%}
.modal h3{margin-bottom:1rem;font-size:1.2rem}
.modal p{margin-bottom:1rem;color:#666;font-size:.9rem}
.modal input{width:100%;padding:.5rem;border:1px solid #ddd;border-radius:.25rem;font:inherit;margin-bottom:1rem}
.modal-actions{display:flex;gap:.5rem;justify-content:flex-end}
@media(max-width:767px){
  .control-row{flex-direction:column;align-items:stretch}
  label{min-width:auto}
  .scheme-colors{flex-direction:column}
  .scheme-color{min-width:auto}
}
</style>
</head>
<body>
<div class="header">
<h1>Vallejo Paint Wheel</h1>
<div class="stats">
<span class="stat">Owned: <b id="owned-count">0</b>/<b id="total-count">0</b></span>
<span class="stat">Wishlist: <b id="wishlist-count">0</b></span>
</div>
</div>

<div class="controls">
<div class="control-row">
<label>Paint Types:</label>
<div class="filter-options">
<label class="filter-option"><input type="checkbox" id="type-regular" checked> Regular</label>
<label class="filter-option"><input type="checkbox" id="type-metallic"> Metallic</label>
<label class="filter-option"><input type="checkbox" id="type-fluo"> Fluo</label>
<label class="filter-option"><input type="checkbox" id="type-xpress"> Xpress</label>
<label class="filter-option"><input type="checkbox" id="type-xpress-intense"> Xpress Intense</label>
</div>
</div>
<div class="control-row">
<label>Collection:</label>
<select id="collection-filter">
<option value="all">All Paints</option>
<option value="owned">Only Owned</option>
<option value="wishlist">Only Wishlist</option>
<option value="missing">Only Missing</option>
</select>
<label>Wheel Size:</label>
<input type="range" id="wheel-size" min="300" max="600" value="400">
<button id="random-btn">Random Paint</button>
<button class="btn-secondary" id="share-btn">Share</button>
<button class="btn-danger" id="reset-btn">Reset</button>
</div>
</div>

<div id="status" class="status"></div>

<div class="wheel-container">
<canvas id="wheel" width="400" height="400"></canvas>
<div id="tooltip" class="tooltip" style="display:none"></div>
</div>

<div id="paint-info" class="paint-info" style="display:none">
<h2>Selected Paint</h2>
<div class="paint-display">
<div class="paint-swatch" id="paint-swatch"></div>
<div class="paint-details" id="paint-details"></div>
</div>
<div class="ownership-controls" id="ownership-controls"></div>
</div>

<div class="schemes" id="schemes" style="display:none">
<h2>Color Schemes with Vallejo Paints</h2>
<div id="schemes-content"></div>
</div>

<div id="modal" class="modal">
<div class="modal-content">
<h3 id="modal-title"></h3>
<p id="modal-text"></p>
<input type="text" id="modal-input" style="display:none">
<div class="modal-actions">
<button id="modal-cancel">Cancel</button>
<button class="btn-primary" id="modal-confirm"></button>
</div>
</div>
</div>

<script>
const canvas = document.getElementById('wheel');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');
const paintInfo = document.getElementById('paint-info');
const paintSwatch = document.getElementById('paint-swatch');
const paintDetails = document.getElementById('paint-details');
const ownershipControls = document.getElementById('ownership-controls');
const schemes = document.getElementById('schemes');
const schemesContent = document.getElementById('schemes-content');
const statusEl = document.getElementById('status');

// Load paints and initialize ownership tracking
let allPaints = window.paintData.map(p => ({ ...p, owned: false, toBuy: false }));
let filteredPaints = [];
let currentPaint = null;
let paintPositions = [];

// Load collection from localStorage
function loadCollection() {
    try {
        const saved = localStorage.getItem('vallejo-paint-data');
        if (saved) {
            const data = JSON.parse(saved);
            const ownedSet = new Set(data.owned || []);
            const toBuySet = new Set(data.toBuy || []);
            
            allPaints.forEach(p => {
                p.owned = ownedSet.has(p.i);
                p.toBuy = toBuySet.has(p.i);
            });
        }
    } catch (e) {
        console.log('No existing collection data found');
    }
}

// Save collection to localStorage
function saveCollection() {
    const data = {
        owned: allPaints.filter(p => p.owned).map(p => p.i),
        toBuy: allPaints.filter(p => p.toBuy).map(p => p.i)
    };
    localStorage.setItem('vallejo-paint-data', JSON.stringify(data));
    updateStats();
}

// Update statistics
function updateStats() {
    const total = filteredPaints.length;
    const owned = filteredPaints.filter(p => p.owned).length;
    const wishlist = filteredPaints.filter(p => p.toBuy).length;
    
    document.getElementById('owned-count').textContent = owned;
    document.getElementById('total-count').textContent = total;
    document.getElementById('wishlist-count').textContent = wishlist;
}

// Show status message
function showStatus(message, duration = 3000) {
    statusEl.textContent = message;
    statusEl.style.display = 'block';
    setTimeout(() => {
        statusEl.style.display = 'none';
    }, duration);
}

// Modal functions
function showModal(title, text, confirmText, onConfirm, showInput = false) {
    const modal = document.getElementById('modal');
    document.getElementById('modal-title').textContent = title;
    document.getElementById('modal-text').textContent = text;
    document.getElementById('modal-confirm').textContent = confirmText;
    const input = document.getElementById('modal-input');
    input.style.display = showInput ? 'block' : 'none';
    input.value = '';
    modal.classList.add('show');
    
    document.getElementById('modal-confirm').onclick = () => {
        modal.classList.remove('show');
        onConfirm(input.value);
    };
    
    document.getElementById('modal-cancel').onclick = () => {
        modal.classList.remove('show');
    };
}

// Share functionality
function encodeCollection() {
    const paints = allPaints;
    const bytes = new Uint8Array(Math.ceil(paints.length / 4));
    paints.forEach((paint, index) => {
        const byteIndex = Math.floor(index / 4);
        const bitOffset = (index % 4) * 2;
        let value = 0;
        if (paint.owned) value = 2;
        else if (paint.toBuy) value = 1;
        bytes[byteIndex] |= value << bitOffset;
    });
    return btoa(String.fromCharCode(...bytes));
}

function decodeCollection(encoded, paints) {
    try {
        const binary = atob(encoded);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
        }
        return paints.map((paint, index) => {
            const byteIndex = Math.floor(index / 4);
            const bitOffset = (index % 4) * 2;
            const value = (bytes[byteIndex] >> bitOffset) & 3;
            return {
                ...paint,
                owned: value === 2,
                toBuy: value === 1
            };
        });
    } catch (e) {
        throw new Error('Invalid share code');
    }
}

function getPaintOwnership(paint) {
    if (paint.owned) return 'owned';
    if (paint.toBuy) return 'wishlist';
    return 'missing';
}

function hexToHsl(hex) {
    const r = parseInt(hex.slice(1, 3), 16) / 255;
    const g = parseInt(hex.slice(3, 5), 16) / 255;
    const b = parseInt(hex.slice(5, 7), 16) / 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0;
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h * 360, s: s * 100, l: l * 100 };
}

function getPaintTypes() {
    const types = [];
    if (document.getElementById('type-regular').checked) types.push(0);
    if (document.getElementById('type-metallic').checked) types.push(1);
    if (document.getElementById('type-fluo').checked) types.push(4);
    if (document.getElementById('type-xpress').checked) types.push(7);
    if (document.getElementById('type-xpress-intense').checked) types.push(8);
    return types;
}

function filterPaints() {
    const types = getPaintTypes();
    const collectionFilter = document.getElementById('collection-filter').value;
    
    filteredPaints = allPaints.filter(p => {
        // Type filter
        if (!types.includes(p.t)) return false;
        
        // Collection filter
        if (collectionFilter === 'owned' && !p.owned) return false;
        if (collectionFilter === 'wishlist' && !p.toBuy) return false;
        if (collectionFilter === 'missing' && (p.owned || p.toBuy)) return false;
        
        return true;
    });
    
    drawPaintWheel();
    updateStats();
}

function drawPaintWheel() {
    const size = parseInt(document.getElementById('wheel-size').value);
    canvas.width = size;
    canvas.height = size;
    
    const centerX = size / 2;
    const centerY = size / 2;
    const maxRadius = size / 2 - 20;
    const minRadius = maxRadius * 0.3;
    
    ctx.clearRect(0, 0, size, size);
    paintPositions = [];
    
    // Draw background
    ctx.fillStyle = '#f8f9fa';
    ctx.fillRect(0, 0, size, size);
    
    // Draw hue rings for reference (subtle)
    for (let r = minRadius; r <= maxRadius; r += (maxRadius - minRadius) / 3) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        ctx.lineWidth = 1;
        ctx.stroke();
    }
    
    // Group paints by hue and find unique positions
    const hueGroups = {};
    filteredPaints.forEach(paint => {
        const hsl = hexToHsl(paint.c);
        const hueGroup = Math.round(hsl.h / 10) * 10;
        if (!hueGroups[hueGroup]) hueGroups[hueGroup] = [];
        hueGroups[hueGroup].push(paint);
    });
    
    // Position paints
    Object.keys(hueGroups).forEach(hueGroup => {
        const paintsInGroup = hueGroups[hueGroup];
        const angle = (parseInt(hueGroup) * Math.PI) / 180;
        
        paintsInGroup.forEach((paint, index) => {
            const hsl = hexToHsl(paint.c);
            const radius = minRadius + (hsl.s / 100) * (maxRadius - minRadius);
            const spreadAngle = angle + (index - (paintsInGroup.length - 1) / 2) * 0.1;
            
            const x = centerX + Math.cos(spreadAngle) * radius;
            const y = centerY + Math.sin(spreadAngle) * radius;
            
            // Draw paint dot with ownership indication
            const dotSize = 6 + (hsl.l / 100) * 4;
            ctx.beginPath();
            ctx.arc(x, y, dotSize, 0, 2 * Math.PI);
            ctx.fillStyle = paint.c;
            ctx.fill();
            
            // Border color based on ownership
            if (paint.owned) {
                ctx.strokeStyle = '#4caf50';
                ctx.lineWidth = 2.5;
            } else if (paint.toBuy) {
                ctx.strokeStyle = '#ff9800';
                ctx.lineWidth = 2.5;
            } else {
                ctx.strokeStyle = hsl.l > 70 ? '#666' : '#fff';
                ctx.lineWidth = 1.5;
            }
            ctx.stroke();
            
            // Store position for interaction
            paintPositions.push({
                paint: paint,
                x: x,
                y: y,
                radius: dotSize
            });
        });
    });
    
    // Draw center info
    ctx.fillStyle = '#333';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(`${filteredPaints.length} paints`, centerX, centerY + 5);
}

function findClosestPaint(targetHex, excludedPaint = null) {
    let closest = filteredPaints[0];
    let minDist = Infinity;
    
    filteredPaints.forEach(p => {
        if (excludedPaint && p.i === excludedPaint.i) return;
        
        const dist = colorDistance(targetHex, p.c);
        if (dist < minDist) {
            minDist = dist;
            closest = p;
        }
    });
    return { paint: closest, distance: minDist };
}

function colorDistance(hex1, hex2) {
    const r1 = parseInt(hex1.slice(1, 3), 16);
    const g1 = parseInt(hex1.slice(3, 5), 16);
    const b1 = parseInt(hex1.slice(5, 7), 16);
    const r2 = parseInt(hex2.slice(1, 3), 16);
    const g2 = parseInt(hex2.slice(3, 5), 16);
    const b2 = parseInt(hex2.slice(5, 7), 16);
    return Math.sqrt((r2 - r1) ** 2 + (g2 - g1) ** 2 + (b2 - b1) ** 2);
}

function selectPaint(paint) {
    currentPaint = paint;
    
    // Update paint info display
    paintInfo.style.display = 'block';
    paintSwatch.style.background = paint.c;
    const ownership = getPaintOwnership(paint);
    paintDetails.innerHTML = `
        <div class="id">${paint.i} - ${paint.n}</div>
        <div class="name">${paint.x ? `Citadel: ${paint.x}` : ''}</div>
        <div class="hex">${paint.c}</div>
        <div class="ownership ${ownership}">${ownership.toUpperCase()}</div>
    `;
    
    // Update ownership controls
    ownershipControls.innerHTML = `
        <button class="${paint.owned ? 'btn-secondary' : ''}" onclick="toggleOwnership('owned')">
            ${paint.owned ? '✓ Owned' : 'Mark as Owned'}
        </button>
        <button class="${paint.toBuy ? 'btn-secondary' : ''}" onclick="toggleOwnership('toBuy')" ${paint.owned ? 'disabled' : ''}>
            ${paint.toBuy ? '✓ Wishlist' : 'Add to Wishlist'}
        </button>
        <button onclick="clearOwnership()" ${!paint.owned && !paint.toBuy ? 'disabled' : ''}>
            Clear
        </button>
    `;
    
    // Generate color schemes
    generateColorSchemes(paint);
    schemes.style.display = 'block';
    
    // Redraw wheel to highlight selected paint
    drawPaintWheel();
    highlightSelectedPaint();
}

function toggleOwnership(type) {
    if (!currentPaint) return;
    
    if (type === 'owned') {
        currentPaint.owned = !currentPaint.owned;
        if (currentPaint.owned) currentPaint.toBuy = false;
    } else if (type === 'toBuy') {
        currentPaint.toBuy = !currentPaint.toBuy;
        if (currentPaint.toBuy) currentPaint.owned = false;
    }
    
    saveCollection();
    selectPaint(currentPaint); // Refresh the display
    drawPaintWheel(); // Update wheel to show new ownership status
    showStatus(`Updated ${currentPaint.i} - ${currentPaint.n}`);
}

function clearOwnership() {
    if (!currentPaint) return;
    
    currentPaint.owned = false;
    currentPaint.toBuy = false;
    saveCollection();
    selectPaint(currentPaint);
    drawPaintWheel();
    showStatus(`Cleared ownership for ${currentPaint.i} - ${currentPaint.n}`);
}

function highlightSelectedPaint() {
    if (!currentPaint) return;
    
    const position = paintPositions.find(pos => pos.paint.i === currentPaint.i);
    if (position) {
        ctx.beginPath();
        ctx.arc(position.x, position.y, position.radius + 4, 0, 2 * Math.PI);
        ctx.strokeStyle = '#1976d2';
        ctx.lineWidth = 3;
        ctx.stroke();
    }
}

function generateColorSchemes(basePaint) {
    const hsl = hexToHsl(basePaint.c);
    let html = '';
    
    // Complementary
    const compHue = (hsl.h + 180) % 360;
    const compHex = hslToHex(compHue, hsl.s, hsl.l);
    const compMatch = findClosestPaint(compHex, basePaint);
    
    // Analogous
    const analog1 = findClosestPaint(hslToHex((hsl.h - 30 + 360) % 360, hsl.s, hsl.l), basePaint);
    const analog2 = findClosestPaint(hslToHex((hsl.h + 30) % 360, hsl.s, hsl.l), basePaint);
    
    // Triadic
    const triad1 = findClosestPaint(hslToHex((hsl.h + 120) % 360, hsl.s, hsl.l), basePaint);
    const triad2 = findClosestPaint(hslToHex((hsl.h + 240) % 360, hsl.s, hsl.l), basePaint);
    
    // Monochromatic
    const light1 = findClosestPaint(hslToHex(hsl.h, hsl.s, Math.min(hsl.l + 30, 90)), basePaint);
    const light2 = findClosestPaint(hslToHex(hsl.h, hsl.s, Math.min(hsl.l + 15, 90)), basePaint);
    const dark1 = findClosestPaint(hslToHex(hsl.h, hsl.s, Math.max(hsl.l - 15, 10)), basePaint);
    const dark2 = findClosestPaint(hslToHex(hsl.h, hsl.s, Math.max(hsl.l - 30, 10)), basePaint);
    
    html += `
        <div class="scheme">
            <h3>Complementary</h3>
            <div class="scheme-colors">
                ${createColorBox(basePaint)}
                ${createColorBox(compMatch.paint, compMatch.distance)}
            </div>
        </div>
        
        <div class="scheme">
            <h3>Analogous (Adjacent Colors)</h3>
            <div class="scheme-colors">
                ${createColorBox(analog1.paint, analog1.distance)}
                ${createColorBox(basePaint)}
                ${createColorBox(analog2.paint, analog2.distance)}
            </div>
        </div>
        
        <div class="scheme">
            <h3>Triadic</h3>
            <div class="scheme-colors">
                ${createColorBox(basePaint)}
                ${createColorBox(triad1.paint, triad1.distance)}
                ${createColorBox(triad2.paint, triad2.distance)}
            </div>
        </div>
        
        <div class="scheme">
            <h3>Monochromatic (Light & Dark)</h3>
            <div class="scheme-colors">
                ${createColorBox(light1.paint, light1.distance)}
                ${createColorBox(light2.paint, light2.distance)}
                ${createColorBox(basePaint)}
                ${createColorBox(dark1.paint, dark1.distance)}
                ${createColorBox(dark2.paint, dark2.distance)}
            </div>
        </div>
    `;
    
    schemesContent.innerHTML = html;
}

function createColorBox(paint, distance = 0) {
    const ownership = getPaintOwnership(paint);
    return `
        <div class="scheme-color" data-paint="${paint.i}">
            <div class="swatch" style="background:${paint.c}"></div>
            <div class="id">${paint.i}</div>
            <div class="name">${paint.n}</div>
            ${distance > 0 ? `<div style="font-size:.65rem;color:#666">Δ${Math.round(distance)}</div>` : ''}
            <div class="ownership ${ownership}">${ownership.toUpperCase()}</div>
        </div>
    `;
}

function hslToHex(h, s, l) {
    s /= 100;
    l /= 100;
    const k = n => (n + h / 30) % 12;
    const a = s * Math.min(l, 1 - l);
    const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
    const toHex = x => Math.round(x * 255).toString(16).padStart(2, '0');
    return `#${toHex(f(0))}${toHex(f(8))}${toHex(f(4))}`;
}

// Event Listeners
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    let found = false;
    paintPositions.forEach(pos => {
        const distance = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
        if (distance <= pos.radius) {
            tooltip.style.display = 'block';
            tooltip.style.left = (e.clientX + 10) + 'px';
            tooltip.style.top = (e.clientY + 10) + 'px';
            const ownership = getPaintOwnership(pos.paint);
            tooltip.innerHTML = `
                <strong>${pos.paint.i}</strong><br>
                ${pos.paint.n}<br>
                ${pos.paint.c}<br>
                <small>${ownership.toUpperCase()}</small>
            `;
            found = true;
        }
    });
    
    if (!found) {
        tooltip.style.display = 'none';
    }
});

canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    paintPositions.forEach(pos => {
        const distance = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
        if (distance <= pos.radius) {
            selectPaint(pos.paint);
        }
    });
});

schemesContent.addEventListener('click', (e) => {
    const colorBox = e.target.closest('.scheme-color');
    if (colorBox) {
        const paintId = colorBox.dataset.paint;
        const paint = filteredPaints.find(p => p.i === paintId);
        if (paint) selectPaint(paint);
    }
});

document.getElementById('random-btn').onclick = () => {
    if (filteredPaints.length > 0) {
        const randomPaint = filteredPaints[Math.floor(Math.random() * filteredPaints.length)];
        selectPaint(randomPaint);
    }
};

document.getElementById('share-btn').onclick = async () => {
    try {
        const encoded = encodeCollection();
        const url = `${location.origin}${location.pathname}#${encoded}`;
        await navigator.clipboard.writeText(url);
        showStatus(`✓ Share link copied! (${url.length} chars)`, 5000);
    } catch (e) {
        showStatus(`✗ Error: ${e.message}`, 5000);
    }
};

document.getElementById('reset-btn').onclick = () => {
    showModal(
        'Reset All Data?', 
        'This will clear all your owned/wishlist data. Share a link first if you want to keep it.',
        'Reset Everything',
        () => {
            allPaints.forEach(p => {
                p.owned = false;
                p.toBuy = false;
            });
            saveCollection();
            filterPaints();
            paintInfo.style.display = 'none';
            schemes.style.display = 'none';
            showStatus('✓ All data reset');
        }
    );
};

// Filter change listeners
document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
    checkbox.addEventListener('change', filterPaints);
});

document.getElementById('collection-filter').addEventListener('change', filterPaints);
document.getElementById('wheel-size').addEventListener('input', filterPaints);

// Handle URL hash for loading shared data
if (location.hash) {
    const encoded = location.hash.slice(1);
    showModal(
        'Load Shared Collection?',
        'This will replace your current collection data with the shared data.',
        'Load Data',
        () => {
            try {
                allPaints = decodeCollection(encoded, allPaints);
                saveCollection();
                filterPaints();
                history.replaceState(null, '', location.pathname);
                showStatus('✓ Collection loaded successfully!');
            } catch (e) {
                showStatus(`✗ Error loading collection: ${e.message}`, 5000);
            }
        }
    );
}

// Initialize
loadCollection();
filterPaints();
</script>
</body>
</html>